%{
	#include <stdio.h>
	#include <stdlib.h>
	#include <iostream>

	//#include "lex.yy.h"
	
	#include "../symbols/symbol.h"
	#include "gsc.tab.hpp"

	int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, void* yyscanner);
	//extern int yyparse();
	void yyerror(YYLTYPE* loc, void* scanner, const char* err);
%}

%define api.pure full
%lex-param { void* scanner }
%parse-param { void* scanner }

%define parse.error verbose

%locations
%initial-action
{
	#if VSCODE_COMPATIBLE_LOCATION
		@$.first_line = @$.last_line = 0;
		@$.first_column = @$.last_column = 0;
	#endif
}

%code requires
{
	#include "../symbols/operator_enum.h"
	
	//
	// Forward declarations for any custom classes used in YYSTYPE
	//
	class Symbol;
	class Include;
	class String;
	class Animtree;
	class Expression;
}

%union {
	OPERATOR_TYPE	op; //operator
	
	int			literal_int;
	float		literal_float;
	char*		literal_string;
	
	char*		t_identifier;
	
	Symbol*		symbol;
	Include*	include;
	Animtree*	animtree;
	
	Expression* expression;
}

%token<literal_string> T_STRING
%token<literal_string> T_FLOAT
%token<literal_string> T_INT

%token INCLUDE
%token USING_ANIMTREE
%token ANIMTREE

%token OP_LPAREN
%token OP_RPAREN
%token FUNC_POINTER_BEGIN

%token OP_LBRACKET
%token OP_RBRACKET
%token OP_LBRACE
%token OP_RBRACE
%token OP_COMMA
%token OP_INC
%token OP_DEC

%token OP_COLON_DOUBLE
%token OP_COLON
%token OP_COLON_SEMI
%token OP_QMARK
%token OP_HASH

%token T_IF
%token T_ELSE
%token T_SWITCH
%token T_CASE
%token T_DEFAULT
%token T_BREAK
%token T_FOR
%token T_WHILE
%token T_CONTINUE
%token T_RETURN
%token T_THREAD
%token T_WAIT
%token<literal_string> T_FILEPATH
%token<t_identifier> T_IDENTIFIER

// Define Token
%token OP_INC_POST OP_DEC_POST OP_LB OP_RB OP_DOT
%token OP_INC_PRE OP_DEC_PRE OP_UPLUS OP_UMINUS OP_NOT OP_BW_NOT
%token OP_MULT OP_DIV OP_MOD
%token OP_ADD OP_SUB
%token OP_LSHIFT OP_RSHIFT
%token OP_CMP_LT OP_CMP_LE OP_CMP_GT OP_CMP_GE
%token OP_CMP_EQ OP_CMP_NEQ
%token OP_BW_AND
%token OP_BW_XOR
%token OP_BW_OR
%token OP_CMP_AND
%token OP_CMP_OR
//ternary
%token OP_ASSIGN OP_ASSIGN_ADD OP_ASSIGN_SUB OP_ASSIGN_MULT OP_ASSIGN_DIV OP_ASSIGN_BW_AND OP_ASSIGN_BW_XOR OP_ASSIGN_BW_OR

%token T_INVALID
%token T_EOF 0

// Operator Precedence ( highest line number = highest precedence )
%right OP_ASSIGN OP_ASSIGN_ADD OP_ASSIGN_SUB OP_ASSIGN_MULT OP_ASSIGN_DIV OP_ASSIGN_BW_AND OP_ASSIGN_BW_XOR OP_ASSIGN_BW_OR
//ternary
%left OP_CMP_OR
%left OP_CMP_AND
%left OP_BW_OR
%left OP_BW_XOR
%left OP_BW_AND
%left OP_CMP_EQ OP_CMP_NEQ
%left OP_CMP_LT OP_CMP_LE OP_CMP_GT OP_CMP_GE
%left OP_LSHIFT OP_RSHIFT
%left OP_ADD OP_SUB
%left OP_MULT OP_DIV OP_MOD
%right OP_INC_PRE OP_DEC_PRE OP_UPLUS OP_UMINUS OP_NOT OP_BW_NOT
%left OP_INC_POST OP_DEC_POST OP_LB OP_RB OP_DOT

//%type<ival> expression
//%type<fval> mixed_expression

%type<symbol> IncludeDirective;
%type<symbol> AnimtreeDirective;
%type<symbol> FunctionDeclaration;

%type<symbol> FormalParameterList;

%type<symbol> SourceElements;
%type<symbol> SourceElement;

%type<symbol> StringLiteral;
%type<symbol> NumericLiteral;
%type<symbol> Block;
%type<symbol> FunctionParameterList;
%type<symbol> FunctionCall;
%type<symbol> FunctionExpression;
%type<symbol> PointerExpression;
%type<symbol> ReferenceExpression;
%type<symbol> AnimReferenceExpression;
%type<symbol> MemberExpression;
%type<symbol> ElementList;
%type<symbol> ListExpression;
%type<symbol> ObjectExpression;	
%type<symbol> LiteralExpression;
%type<symbol> OptionalExpression;
%type<expression> BasicExpression;
%type<op> OperatorPostfix;
%type<op> OperatorPrefix;	
%type<op> OperatorMid;
%type<expression> e;
%type<symbol> Expression;
%type<symbol> ExpressionStatement;
%type<symbol> ReturnStatement;
%type<symbol> WaitStatement;
%type<symbol> EmptyStatement;
%type<symbol> IfStatement;
%type<symbol> SwitchStatement;
%type<symbol> CaseStatement;
%type<symbol> LoopStatement;
%type<symbol> Statement;
%type<symbol> StatementList;

%destructor { printf("BISON SYMBOL DESTRUCTOR\n"); } <*>

%start Program

%%

IncludeDirective:
	INCLUDE T_FILEPATH OP_COLON_SEMI
		{
			$$ = new Include(new String($2, @2), @$); 
		};
		
AnimtreeDirective:
	USING_ANIMTREE OP_LPAREN T_STRING OP_RPAREN OP_COLON_SEMI
		{
			$$ = new Animtree(new String($3, @3), @$); 
		};

FunctionDeclaration:
	T_IDENTIFIER OP_LPAREN FormalParameterList OP_RPAREN Block
	{
		$$ = new Symbol(@$);
		$$->AddChild(new Group($3, @3));
		$$->AddChild($5);
	};

FormalParameterList
	: FormalParameterList OP_COMMA T_IDENTIFIER
		{ $$->AddToEnd( new String($3, @3) ); }
	| T_IDENTIFIER
		{ $$ = new String($1, @1); }
	|
		{ $$ = NULL; };

SourceElement:
	IncludeDirective
	| AnimtreeDirective
	| FunctionDeclaration

SourceElements:
	SourceElements SourceElement
		{
			$$->AddToEnd($2);
		}
	| SourceElement
	;

Program: SourceElements T_EOF
	{
		for(Symbol* a = $1; a; a = a->NextElem())
		{
			a->PrintInfoRecursive();
		}
		
		printf("\nFILE RANGE: %d[%d] - %d[%d]\n", @$.first_line, @$.first_column, @$.last_line, @$.last_column);
	}
	
StringLiteral
	: T_STRING 
		{ $$ = new String($1, @1); }
	| OP_BW_AND T_STRING 
		{ $$ = new String($2, @$); }
	| OP_HASH T_STRING 
		{ $$ = new String($2, @$); }
	;

NumericLiteral
	: T_INT 
		{ $$ = new String($1, @1); }
	| T_FLOAT 
		{ $$ = new String($1, @1); }
	;

Block
	: OP_LBRACE StatementList OP_RBRACE 
		{ $$ = new Group($2, @2); }
	;

FunctionParameterList
	: Expression 
		{ $$ = new Symbol(@$); }
	| FunctionParameterList OP_COMMA Expression 
		{ $$ = new Symbol(@$); }
	|  
		{ $$ = new Symbol(@$); }
	;

FunctionCall
	: T_IDENTIFIER OP_LPAREN FunctionParameterList OP_RPAREN 
		{ $$ = new Symbol(@$); }
	| T_THREAD T_IDENTIFIER OP_LPAREN FunctionParameterList OP_RPAREN 
		{ $$ = new Symbol(@$); }
	| PointerExpression OP_LPAREN FunctionParameterList OP_RPAREN 
		{ $$ = new Symbol(@$); }
	| T_THREAD PointerExpression OP_LPAREN FunctionParameterList OP_RPAREN 
		{ $$ = new Symbol(@$); }
	| ReferenceExpression OP_LPAREN FunctionParameterList OP_RPAREN 
		{ $$ = new Symbol(@$); }
	| T_THREAD ReferenceExpression OP_LPAREN FunctionParameterList OP_RPAREN 
		{ $$ = new Symbol(@$); }
	;

FunctionExpression
	: ObjectExpression FunctionCall 
		{ $$ = new Symbol(@$); }
	| FunctionCall 
		{ $$ = new Symbol(@$); }
	;

PointerExpression
	: FUNC_POINTER_BEGIN ObjectExpression OP_RBRACKET OP_RBRACKET 
		{ $$ = new Symbol(@$); }
	| FUNC_POINTER_BEGIN ReferenceExpression OP_RBRACKET OP_RBRACKET 
		{ $$ = new Symbol(@$); }
	;

ReferenceExpression
	: T_FILEPATH OP_COLON_DOUBLE T_IDENTIFIER 
		{ $$ = new Symbol(@$); }
	| OP_COLON_DOUBLE T_IDENTIFIER 
		{ $$ = new Symbol(@$); }
	;

AnimReferenceExpression
	: OP_MOD T_IDENTIFIER 
		{ $$ = new Symbol(@$); }
	;

MemberExpression
	: ObjectExpression OP_LBRACKET Expression OP_RBRACKET 
		{ $$ = new Symbol(@$); }
	| ObjectExpression OP_DOT ObjectExpression 
		{ $$ = new Symbol(@$); }
	| OP_LBRACKET OP_RBRACKET 
		{ $$ = new Symbol(@$); }
	;

ElementList
	: Expression OP_COMMA Expression //Lists must have at least two elements 
		{ $$ = new Symbol(@$); }
	| ElementList OP_COMMA Expression 
		{ $$ = new Symbol(@$); }
	;

ListExpression
	: OP_LPAREN ElementList OP_RPAREN 
		{ $$ = new Symbol(@$); }
	;

ObjectExpression
	: T_IDENTIFIER 
		{ $$ = new String($1, @1); }

	| FunctionExpression 
		{ $$ = new Symbol(@$); }
	| MemberExpression 
		{ $$ = new Symbol(@$); }
	| OP_LPAREN ObjectExpression OP_RPAREN 
		{ $$ = new Symbol(@$); }
	;
	
LiteralExpression
	: NumericLiteral 
		{ $$ = $1; }
	| StringLiteral 
		{ $$ = $1; }
	;

OptionalExpression
	: Expression 
		{ $$ = new Symbol(@$); }
	| 
		{ $$ = new Symbol(@$); }
	;

BasicExpression
	: ObjectExpression 
		{ $$ = (Expression*)$1; }
	| LiteralExpression 
		{ $$ = (Expression*)$1; }
	| ListExpression //used for things like vectors 
		{ $$ = new Expression(@$); }
	| ReferenceExpression 
		{ $$ = new Expression(@$); }
	| ANIMTREE 
		{ $$ = new Expression(@$); }
	;

OperatorPostfix
	: OP_INC
		{ $$ = OP_TYPE_INC; };
	| OP_DEC
		{ $$ = OP_TYPE_DEC; };
	;
	
OperatorPrefix
	: OP_INC
		{ $$ = OP_TYPE_INC; };
	| OP_DEC
		{ $$ = OP_TYPE_DEC; };
	| OP_ADD
		{ $$ = OP_TYPE_ADD; };
	| OP_SUB
		{ $$ = OP_TYPE_SUB; };
	| OP_BW_NOT
		{ $$ = OP_TYPE_BW_NOT; };
	| OP_NOT
		{ $$ = OP_TYPE_NOT; };
	;
	
OperatorMid
	: OP_MULT 
		{ $$ = OP_TYPE_MULT; };
	| OP_DIV
		{ $$ = OP_TYPE_DIV; };
	| OP_MOD
		{ $$ = OP_TYPE_MOD; };
	| OP_ADD
		{ $$ = OP_TYPE_ADD; };
	| OP_SUB
		{ $$ = OP_TYPE_SUB; };
	| OP_LSHIFT
		{ $$ = OP_TYPE_LSHIFT; };
	| OP_RSHIFT
		{ $$ = OP_TYPE_RSHIFT; };
	| OP_CMP_LT
		{ $$ = OP_TYPE_CMP_LT; };
	| OP_CMP_LE
		{ $$ = OP_TYPE_CMP_LE; };
	| OP_CMP_GT
		{ $$ = OP_TYPE_CMP_GT; };
	| OP_CMP_GE
		{ $$ = OP_TYPE_CMP_GE; };
	| OP_CMP_EQ
		{ $$ = OP_TYPE_CMP_EQ; };
	| OP_CMP_NEQ
		{ $$ = OP_TYPE_CMP_NEQ; };
	| OP_BW_AND
		{ $$ = OP_TYPE_BW_AND; };
	| OP_BW_OR
		{ $$ = OP_TYPE_BW_OR; };
	| OP_CMP_AND
		{ $$ = OP_TYPE_CMP_AND; };
	| OP_CMP_OR
		{ $$ = OP_TYPE_CMP_OR; };
	| OP_ASSIGN
		{ $$ = OP_TYPE_ASSIGN; };
	| OP_ASSIGN_ADD
		{ $$ = OP_TYPE_ASSIGN_ADD; };
	| OP_ASSIGN_SUB
		{ $$ = OP_TYPE_ASSIGN_SUB; };
	| OP_ASSIGN_MULT
		{ $$ = OP_TYPE_ASSIGN_MULT; };
	| OP_ASSIGN_DIV
		{ $$ = OP_TYPE_ASSIGN_DIV; };
	| OP_ASSIGN_BW_AND
		{ $$ = OP_TYPE_ASSIGN_BW_AND; };
	| OP_ASSIGN_BW_XOR
		{ $$ = OP_TYPE_ASSIGN_BW_XOR; };
	| OP_ASSIGN_BW_OR
		{ $$ = OP_TYPE_ASSIGN_BW_OR; };
	;

e
	: BasicExpression 
		{ $$ = $1; }
	| e OperatorPostfix 
		{ $$ = new Expression($1, $2, @$); }
	| OperatorPrefix e 
		{ $$ = new Expression($1, $2, @$); }
	| e OperatorMid e 
		{ $$ = new Expression($1, $2, $3, @$); }
	| AnimReferenceExpression 
		{ $$ = (Expression*)$1; }
	| OP_LPAREN e OP_RPAREN 
		{ $$ = (Expression*)$2; }
	;

Expression
	: e 
		{ $$ = $1; }
	;
	
ExpressionStatement
	: Expression OP_COLON_SEMI 
		{ $$ = $1; /*new Symbol(@$);*/ }
	;

ReturnStatement
	: T_RETURN OP_COLON_SEMI 
		{ $$ = new Symbol(@$); }
	| T_RETURN Expression OP_COLON_SEMI 
		{ $$ = new Symbol(@$); }
	;

WaitStatement
	: T_WAIT Expression OP_COLON_SEMI 
		{ $$ = new Symbol(@$); }
	| T_WAIT OP_LPAREN Expression OP_RPAREN OP_COLON_SEMI 
		{ $$ = new Symbol(@$); }
	;

EmptyStatement
	: OP_COLON_SEMI
		{ $$ = new Symbol(@$); }
	;

IfStatement
	: T_IF OP_LPAREN Expression OP_RPAREN Statement 
		{ $$ = new Symbol(@$); }
	| T_ELSE Statement
		{ $$ = new Symbol(@$); }
	;

SwitchStatement
	: T_SWITCH OP_LPAREN Expression OP_RPAREN Statement 
		{ $$ = new Symbol(@$); }
	;

CaseStatement
	: T_CASE LiteralExpression OP_COLON 
		{ $$ = new Symbol(@$); }
	| T_DEFAULT OP_COLON 
		{ $$ = new Symbol(@$); }
	;

LoopStatement
	: T_WHILE OP_LPAREN Expression OP_RPAREN Statement 
		{ $$ = new Symbol(@$); }
	| T_FOR OP_LPAREN OptionalExpression OP_COLON_SEMI OptionalExpression OP_COLON_SEMI OptionalExpression OP_RPAREN Statement 
		{ $$ = new Symbol(@$); }
	;
		
Statement
	: Block 
		{ $$ = $1; }
	| WaitStatement 
		{ $$ = $1; }
	| ExpressionStatement 
		{ $$ = $1; }
	| IfStatement 
		{ $$ = $1; }
	| SwitchStatement 
		{ $$ = $1; }
	| CaseStatement 
		{ $$ = $1; }
	| LoopStatement 
		{ $$ = $1; }
	| ReturnStatement 
		{ $$ = $1; }
	| T_BREAK OP_COLON_SEMI 
		{ $$ = new Symbol(@$); }
	| T_CONTINUE OP_COLON_SEMI 
		{ $$ = new Symbol(@$); }
	| EmptyStatement 
		{ $$ = $1; }
	;

StatementList
	: StatementList Statement 
		{ $$->AddToEnd($2); }
	| Statement
		{ $$ = $1; }
	| 
		{ $$ = NULL; }
	;

%%

#include <sys/time.h>

#define DEBUG 1

void yyerror(YYLTYPE* loc, void* scanner, const char* err) {
	fprintf(stderr, "PARSE ERROR AT LINE %d(%d): %s\n",
		loc->first_line, loc->first_column,
		err);
		
#if !(DEBUG)
	exit(1);
#endif
}

extern int yylex_init(void** ptr_yy_globals);
extern int yylex_destroy(void* yyscanner);
extern void yyset_in(FILE* in, void* scanner);
extern void yyset_out(FILE* out, void* scanner);

int main(int argc, char** argv) {
	FILE* in = argc > 1 ? fopen(argv[1], "r") : stdin;
	
#if DEBUG
while(1){
#endif

	timespec start;
	clock_gettime(CLOCK_REALTIME, &start);

	void* myscanner;
	yylex_init(&myscanner);
	
	yyset_in(in, myscanner );
	yyset_out(stdout, myscanner);
	
	yyparse(myscanner);
	yylex_destroy(myscanner);
	
	timespec end;
	clock_gettime(CLOCK_REALTIME, &end);
	
	if(argc > 1)
	{
		int nanos = end.tv_nsec - start.tv_nsec;
		fprintf(stderr, "Parsed in %f ms\n", (double)nanos / 1000000.0);
		
		printf("\n");
		exit(0);
	}
	
#if DEBUG
}
#endif

	return 0;
}
