%{
	#include <stdio.h>
	#include <stdlib.h>
	#include <iostream>

	//#include "lex.yy.h"
	
	#include "symbol.h"
	#include "gsc.tab.hpp"

	int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, void* yyscanner);
	//extern int yyparse();
	void yyerror(YYLTYPE* loc, void* scanner, const char* err);
%}

%define api.pure full
%lex-param { void* scanner }
%parse-param { void* scanner }

%define parse.error verbose

%locations
%initial-action
{
	#if VSCODE_COMPATIBLE_LOCATION
		@$.first_line = @$.last_line = 0;
		@$.first_column = @$.last_column = 0;
	#endif
}

%code requires
{
	//
	// Forward declarations for any custom classes used in YYSTYPE
	//
	class Symbol;
	class Include;
	class String;
	class Animtree;
}

%union {
	int			literal_int;
	float		literal_float;
	char*		literal_string;
	
	char*		t_identifier;
	
	Symbol*		symbol;
	Include*	include;
	Animtree*	animtree;
}

%token<literal_string> T_STRING
%token<literal_float> T_FLOAT
%token<literal_string> T_INT

%token INCLUDE
%token USING_ANIMTREE
%token ANIMTREE

%token OP_LPAREN
%token OP_RPAREN
%token FUNC_POINTER_BEGIN

%token OP_LBRACKET
%token OP_RBRACKET
%token OP_LBRACE
%token OP_RBRACE
%token OP_COMMA
%token OP_INC
%token OP_DEC

%token OP_COLON_DOUBLE
%token OP_COLON
%token OP_COLON_SEMI
%token OP_QMARK
%token OP_HASH

%token T_IF
%token T_ELSE
%token T_SWITCH
%token T_CASE
%token T_DEFAULT
%token T_BREAK
%token T_FOR
%token T_WHILE
%token T_CONTINUE
%token T_RETURN
%token T_THREAD
%token T_WAIT
%token<literal_string> T_FILEPATH
%token<t_identifier> T_IDENTIFIER

// Define Token
%token OP_INC_POST OP_DEC_POST OP_LB OP_RB OP_DOT
%token OP_INC_PRE OP_DEC_PRE OP_UPLUS OP_UMINUS OP_NOT OP_BW_NOT
%token OP_MULT OP_DIV OP_MOD
%token OP_ADD OP_SUB
%token OP_LSHIFT OP_RSHIFT
%token OP_CMP_LT OP_CMP_LE OP_CMP_GT OP_CMP_GE
%token OP_CMP_EQ OP_CMP_NEQ
%token OP_BW_AND
%token OP_BW_XOR
%token OP_BW_OR
%token OP_CMP_AND
%token OP_CMP_OR
//ternary
%token OP_ASSIGN OP_ASSIGN_ADD OP_ASSIGN_SUB OP_ASSIGN_MULT OP_ASSIGN_DIV OP_ASSIGN_BW_AND OP_ASSIGN_BW_XOR OP_ASSIGN_BW_OR

%token T_INVALID
%token T_EOF 0

// Operator Precedence
/*%left OP_INC_POST OP_DEC_POST OP_LB OP_RB OP_DOT
%right OP_INC_PRE OP_DEC_PRE OP_UPLUS OP_UMINUS OP_NOT OP_BW_NOT
%left OP_MULT OP_DIV OP_MOD
%left OP_ADD OP_SUB
%left OP_LSHIFT OP_RSHIFT
%left OP_CMP_LT OP_CMP_LE OP_CMP_GT OP_CMP_GE
%left OP_CMP_EQ OP_CMP_NEQ
%left OP_BW_AND
%left OP_BW_XOR
%left OP_BW_OR
%left OP_CMP_AND
%left OP_CMP_OR
//ternary
%right OP_ASSIGN OP_ASSIGN_ADD OP_ASSIGN_SUB OP_ASSIGN_MULT OP_ASSIGN_DIV OP_ASSIGN_BW_AND OP_ASSIGN_BW_XOR OP_ASSIGN_BW_OR
*/

//%type<ival> expression
//%type<fval> mixed_expression

%type<symbol> IncludeDirective;
%type<symbol> AnimtreeDirective;
%type<symbol> FunctionDeclaration;

%type<symbol> FormalParameterList;

%type<symbol> SourceElements;
%type<symbol> SourceElement;

%type<symbol> StringLiteral;
%type<symbol> NumericLiteral;
%type<symbol> Block;
%type<symbol> FunctionParameterList;
%type<symbol> FunctionCall;
%type<symbol> FunctionExpression;
%type<symbol> PointerExpression;
%type<symbol> ReferenceExpression;
%type<symbol> AnimReferenceExpression;
%type<symbol> MemberExpression;
%type<symbol> ElementList;
%type<symbol> ListExpression;
%type<symbol> ObjectExpression;	
%type<symbol> LiteralExpression;
%type<symbol> OptionalExpression;
%type<symbol> BasicExpression;
%type<symbol> OperatorPostfix;
%type<symbol> OperatorPrefix;	
%type<symbol> OperatorMid;
%type<symbol> e;
%type<symbol> Expression;
%type<symbol> ExpressionStatement;
%type<symbol> ReturnStatement;
%type<symbol> WaitStatement;
%type<symbol> EmptyStatement;
%type<symbol> IfStatement;
%type<symbol> SwitchStatement;
%type<symbol> CaseStatement;
%type<symbol> LoopStatement;
%type<symbol> Statement;
%type<symbol> StatementList;

%start Program

%%

IncludeDirective:
	INCLUDE T_FILEPATH OP_COLON_SEMI
		{
			$$ = new Include(new String($2, @2), @$); 
		}
		
AnimtreeDirective:
	USING_ANIMTREE OP_LPAREN T_STRING OP_RPAREN OP_COLON_SEMI
		{
			$$ = new Animtree(new String($3, @3), @$); 
		}

FunctionDeclaration:
	T_IDENTIFIER OP_LPAREN FormalParameterList OP_RPAREN Block
	{
		$$ = new Symbol(@$);
		$$->AddChild(new Symbol(@3));
		/*for(String* param = (String*)$3; param; param = (String*)param->prev)
		{
			printf("PARAM: %s\n", param->value);
		}*/
	}

FormalParameterList
	: FormalParameterList OP_COMMA T_IDENTIFIER
		{
			//$$->next = new String($3, @3);
			//$$->next->prev = $$;
			//$$ = $$->next;
		}
	| T_IDENTIFIER
		{
			//$$ = new String($1, @1);
		}
	|
		{
			//$$ = new String("", @$);
		}

SourceElement:
	IncludeDirective
	| AnimtreeDirective
	| FunctionDeclaration

SourceElements:
	SourceElements SourceElement
		{
			$$->AddToEnd($2);
		}
	| SourceElement
	;

Program: SourceElements T_EOF
	{
		for(Symbol* a = $1; a; a = a->NextElem())
		{
			a->PrintInfo();
		}
		
		printf("\nFILE RANGE: %d[%d] - %d[%d]\n", @$.first_line, @$.first_column, @$.last_line, @$.last_column);
	}
	
StringLiteral
	: T_STRING { $$ = new Symbol(@$); }
	| OP_BW_AND T_STRING { $$ = new Symbol(@$); }
	| OP_HASH T_STRING { $$ = new Symbol(@$); }
	;

NumericLiteral
	: T_INT { $$ = new Symbol(@$); }
	| T_FLOAT { $$ = new Symbol(@$); }
	;

Block
	: OP_LBRACE StatementList OP_RBRACE { $$ = new Symbol(@$); }
	;

FunctionParameterList
	: Expression { $$ = new Symbol(@$); }
	| FunctionParameterList OP_COMMA Expression { $$ = new Symbol(@$); }
	|  { $$ = new Symbol(@$); }
	;

FunctionCall
	: T_IDENTIFIER OP_LPAREN FunctionParameterList OP_RPAREN { $$ = new Symbol(@$); }
	| T_THREAD T_IDENTIFIER OP_LPAREN FunctionParameterList OP_RPAREN { $$ = new Symbol(@$); }
	| PointerExpression OP_LPAREN FunctionParameterList OP_RPAREN { $$ = new Symbol(@$); }
	| T_THREAD PointerExpression OP_LPAREN FunctionParameterList OP_RPAREN { $$ = new Symbol(@$); }
	| ReferenceExpression OP_LPAREN FunctionParameterList OP_RPAREN { $$ = new Symbol(@$); }
	| T_THREAD ReferenceExpression OP_LPAREN FunctionParameterList OP_RPAREN { $$ = new Symbol(@$); }
	;

FunctionExpression
	: ObjectExpression FunctionCall { $$ = new Symbol(@$); }
	| FunctionCall { $$ = new Symbol(@$); }
	;

PointerExpression
	: FUNC_POINTER_BEGIN ObjectExpression OP_RBRACKET OP_RBRACKET { $$ = new Symbol(@$); }
	| FUNC_POINTER_BEGIN ReferenceExpression OP_RBRACKET OP_RBRACKET { $$ = new Symbol(@$); }
	;

ReferenceExpression
	: T_FILEPATH OP_COLON_DOUBLE T_IDENTIFIER { $$ = new Symbol(@$); }
	| OP_COLON_DOUBLE T_IDENTIFIER { $$ = new Symbol(@$); }
	;

AnimReferenceExpression
	: OP_MOD T_IDENTIFIER { $$ = new Symbol(@$); }
	;

MemberExpression
	: ObjectExpression OP_LBRACKET Expression OP_RBRACKET { $$ = new Symbol(@$); }
	| ObjectExpression OP_DOT ObjectExpression { $$ = new Symbol(@$); }
	| OP_LBRACKET OP_RBRACKET { $$ = new Symbol(@$); }
	;

ElementList
	: Expression OP_COMMA Expression //Lists must have at least two elements { $$ = new Symbol(@$); }
	| ElementList OP_COMMA Expression { $$ = new Symbol(@$); }
	;

ListExpression
	: OP_LPAREN ElementList OP_RPAREN { $$ = new Symbol(@$); }
	;

ObjectExpression
	: T_IDENTIFIER { $$ = new Symbol(@$); }

	| FunctionExpression { $$ = new Symbol(@$); }
	| MemberExpression { $$ = new Symbol(@$); }
	| OP_LPAREN ObjectExpression OP_RPAREN { $$ = new Symbol(@$); }
	;
	
LiteralExpression
	: NumericLiteral { $$ = new Symbol(@$); }
	| StringLiteral { $$ = new Symbol(@$); }
	;

OptionalExpression
	: Expression { $$ = new Symbol(@$); }
	| { $$ = new Symbol(@$); }
	;

BasicExpression
	: ObjectExpression { $$ = new Symbol(@$); }
	| LiteralExpression { $$ = new Symbol(@$); }
	| ListExpression //used for things like vectors { $$ = new Symbol(@$); }
	| ReferenceExpression { $$ = new Symbol(@$); }
	| ANIMTREE { $$ = new Symbol(@$); }
	;

OperatorPostfix
	: OP_INC { $$ = new Symbol(@$); }
	| OP_DEC { $$ = new Symbol(@$); }
	;
	
OperatorPrefix
	: OP_INC { $$ = new Symbol(@$); }
	| OP_DEC { $$ = new Symbol(@$); }
	| OP_ADD { $$ = new Symbol(@$); }
	| OP_SUB { $$ = new Symbol(@$); }
	| OP_BW_NOT { $$ = new Symbol(@$); }
	| OP_NOT { $$ = new Symbol(@$); }
	;
	
OperatorMid
	: OP_MULT { $$ = new Symbol(@$); }
	| OP_DIV { $$ = new Symbol(@$); }
	| OP_MOD { $$ = new Symbol(@$); }
	| OP_ADD { $$ = new Symbol(@$); }
	| OP_SUB { $$ = new Symbol(@$); }
	| OP_LSHIFT { $$ = new Symbol(@$); }
	| OP_RSHIFT { $$ = new Symbol(@$); }
	| OP_CMP_LT { $$ = new Symbol(@$); }
	| OP_CMP_LE { $$ = new Symbol(@$); }
	| OP_CMP_GT { $$ = new Symbol(@$); }
	| OP_CMP_GE { $$ = new Symbol(@$); }
	| OP_CMP_EQ { $$ = new Symbol(@$); }
	| OP_CMP_NEQ { $$ = new Symbol(@$); }
	| OP_BW_AND { $$ = new Symbol(@$); }
	| OP_BW_OR { $$ = new Symbol(@$); }
	| OP_CMP_AND { $$ = new Symbol(@$); }
	| OP_CMP_OR { $$ = new Symbol(@$); }
	| OP_ASSIGN { $$ = new Symbol(@$); }
	| OP_ASSIGN_ADD { $$ = new Symbol(@$); }
	| OP_ASSIGN_SUB { $$ = new Symbol(@$); }
	| OP_ASSIGN_MULT { $$ = new Symbol(@$); }
	| OP_ASSIGN_DIV { $$ = new Symbol(@$); }
	| OP_ASSIGN_BW_AND { $$ = new Symbol(@$); }
	| OP_ASSIGN_BW_XOR { $$ = new Symbol(@$); }
	| OP_ASSIGN_BW_OR { $$ = new Symbol(@$); }
	;

e
	: BasicExpression { $$ = new Symbol(@$); }
	| e OperatorPostfix { $$ = new Symbol(@$); }
	| OperatorPrefix e { $$ = new Symbol(@$); }
	| e OperatorMid e { $$ = new Symbol(@$); }
	| AnimReferenceExpression { $$ = new Symbol(@$); }
	| OP_LPAREN e OP_RPAREN { $$ = new Symbol(@$); }
	;

Expression
	: e { $$ = new Symbol(@$); }
	;
	
ExpressionStatement
	: Expression OP_COLON_SEMI { $$ = new Symbol(@$); }
	;

ReturnStatement
	: T_RETURN OP_COLON_SEMI { $$ = new Symbol(@$); }
	| T_RETURN Expression OP_COLON_SEMI { $$ = new Symbol(@$); }
	;

WaitStatement
	: T_WAIT Expression OP_COLON_SEMI { $$ = new Symbol(@$); }
	| T_WAIT OP_LPAREN Expression OP_RPAREN OP_COLON_SEMI { $$ = new Symbol(@$); }
	;

EmptyStatement
	: OP_COLON_SEMI
		{ $$ = new Symbol(@$); }
	;

IfStatement
	: T_IF OP_LPAREN Expression OP_RPAREN Statement { $$ = new Symbol(@$); }
	| T_ELSE T_IF OP_LPAREN Expression OP_RPAREN Statement { $$ = new Symbol(@$); }
	| T_ELSE Statement { $$ = new Symbol(@$); }
	;

SwitchStatement
	: T_SWITCH OP_LPAREN Expression OP_RPAREN Statement { $$ = new Symbol(@$); }
	;

CaseStatement
	: T_CASE LiteralExpression OP_COLON { $$ = new Symbol(@$); }
	| T_DEFAULT OP_COLON { $$ = new Symbol(@$); }
	;

LoopStatement
	: T_WHILE OP_LPAREN Expression OP_RPAREN Statement { $$ = new Symbol(@$); }
	| T_FOR OP_LPAREN OptionalExpression OP_COLON_SEMI OptionalExpression OP_COLON_SEMI OptionalExpression OP_RPAREN Statement { $$ = new Symbol(@$); }
	;

Statement
	: Block { $$ = new Symbol(@$); }
	| WaitStatement { $$ = new Symbol(@$); }
	| ExpressionStatement { $$ = new Symbol(@$); }
	| IfStatement { $$ = new Symbol(@$); }
	| SwitchStatement { $$ = new Symbol(@$); }
	| CaseStatement { $$ = new Symbol(@$); }
	| LoopStatement { $$ = new Symbol(@$); }
	| ReturnStatement { $$ = new Symbol(@$); }
	| T_BREAK OP_COLON_SEMI { $$ = new Symbol(@$); }
	| T_CONTINUE OP_COLON_SEMI { $$ = new Symbol(@$); }
	| EmptyStatement { $$ = new Symbol(@$); }
	;

StatementList
	: StatementList Statement { $$ = new Symbol(@$); }
	| { $$ = new Symbol(@$); }
	;

%%

#include <sys/time.h>

#define DEBUG 1

void yyerror(YYLTYPE* loc, void* scanner, const char* err) {
	fprintf(stderr, "PARSE ERROR AT LINE %d(%d): %s\n",
		loc->first_line, loc->first_column,
		err);
		
#if !(DEBUG)
	exit(1);
#endif
}

extern int yylex_init(void** ptr_yy_globals);
extern int yylex_destroy(void* yyscanner);
extern void yyset_in(FILE* in, void* scanner);
extern void yyset_out(FILE* out, void* scanner);

int main(int argc, char** argv) {
	FILE* in = argc > 1 ? fopen(argv[1], "r") : stdin;
	
#if DEBUG
while(1){
#endif

	void* myscanner;
	yylex_init(&myscanner);
	
	yyset_in(in, myscanner );
	yyset_out(stdout, myscanner);
	
	yyparse(myscanner);
	yylex_destroy(myscanner);
	
	timespec end;
	clock_gettime(CLOCK_REALTIME, &end);
	
	if(argc > 1)
	{
		printf("\n");
		exit(0);
	}
	
#if DEBUG
}
#endif

	return 0;
}
