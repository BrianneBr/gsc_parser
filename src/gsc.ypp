%{
	#include <stdio.h>
	#include <stdlib.h>
	#include <iostream>

	//#include "lex.yy.h"
	
	#include "symbol.h"
	#include "gsc.tab.hpp"

	int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, void* yyscanner);
	//extern int yyparse();
	void yyerror(YYLTYPE* loc, void* scanner, const char* err);
%}

%define api.pure full
%lex-param { void* scanner }
%parse-param { void* scanner }

%define parse.error verbose

%locations
%initial-action
{
	#if VSCODE_COMPATIBLE_LOCATION
		@$.first_line = @$.last_line = 0;
		@$.first_column = @$.last_column = 0;
	#endif
}

%code requires
{
	//
	// Forward declarations for any custom classes used in YYSTYPE
	//
	class Symbol;
	class Include;
	class String;
	class Animtree;
}

%union {
	int			literal_int;
	float		literal_float;
	char*		literal_string;
	
	char*		t_identifier;
	
	Symbol*		symbol;
	Include*	include;
	Animtree*	animtree;
}

%token<literal_string> T_STRING
%token<literal_float> T_FLOAT
%token<literal_string> T_INT

%token INCLUDE
%token USING_ANIMTREE
%token ANIMTREE

%token OP_LPAREN
%token OP_RPAREN
%token FUNC_POINTER_BEGIN

%token OP_LBRACKET
%token OP_RBRACKET
%token OP_LBRACE
%token OP_RBRACE
%token OP_COMMA
%token OP_INC
%token OP_DEC

%token OP_COLON_DOUBLE
%token OP_COLON
%token OP_COLON_SEMI
%token OP_QMARK
%token OP_HASH

%token T_IF
%token T_ELSE
%token T_SWITCH
%token T_CASE
%token T_DEFAULT
%token T_BREAK
%token T_FOR
%token T_WHILE
%token T_CONTINUE
%token T_RETURN
%token T_THREAD
%token T_WAIT
%token<literal_string> T_FILEPATH
%token<t_identifier> T_IDENTIFIER

// Define Token
%token OP_INC_POST OP_DEC_POST OP_LB OP_RB OP_DOT
%token OP_INC_PRE OP_DEC_PRE OP_UPLUS OP_UMINUS OP_NOT OP_BW_NOT
%token OP_MULT OP_DIV OP_MOD
%token OP_ADD OP_SUB
%token OP_LSHIFT OP_RSHIFT
%token OP_CMP_LT OP_CMP_LE OP_CMP_GT OP_CMP_GE
%token OP_CMP_EQ OP_CMP_NEQ
%token OP_BW_AND
%token OP_BW_XOR
%token OP_BW_OR
%token OP_CMP_AND
%token OP_CMP_OR
//ternary
%token OP_ASSIGN OP_ASSIGN_ADD OP_ASSIGN_SUB OP_ASSIGN_MULT OP_ASSIGN_DIV OP_ASSIGN_BW_AND OP_ASSIGN_BW_XOR OP_ASSIGN_BW_OR

%token T_INVALID
%token T_EOF 0

// Operator Precedence
/*%left OP_INC_POST OP_DEC_POST OP_LB OP_RB OP_DOT
%right OP_INC_PRE OP_DEC_PRE OP_UPLUS OP_UMINUS OP_NOT OP_BW_NOT
%left OP_MULT OP_DIV OP_MOD
%left OP_ADD OP_SUB
%left OP_LSHIFT OP_RSHIFT
%left OP_CMP_LT OP_CMP_LE OP_CMP_GT OP_CMP_GE
%left OP_CMP_EQ OP_CMP_NEQ
%left OP_BW_AND
%left OP_BW_XOR
%left OP_BW_OR
%left OP_CMP_AND
%left OP_CMP_OR
//ternary
%right OP_ASSIGN OP_ASSIGN_ADD OP_ASSIGN_SUB OP_ASSIGN_MULT OP_ASSIGN_DIV OP_ASSIGN_BW_AND OP_ASSIGN_BW_XOR OP_ASSIGN_BW_OR
*/
//%type<ival> expression
//%type<fval> mixed_expression

%type<include> IncludeDirective;
%type<animtree> AnimtreeDirective;
%type<symbol> FunctionDeclaration;

%type<symbol> FormalParameterList;

%type<symbol> SourceElements;
%type<symbol> SourceElement;

%start Program

%%

IncludeDirective:
	INCLUDE T_FILEPATH
		{
			$$ = new Include(new String($2, @2), @$); 
		}
		
AnimtreeDirective:
	USING_ANIMTREE OP_LPAREN T_STRING OP_RPAREN OP_COLON_SEMI
		{
			$$ = new Animtree(new String($3, @3), @$); 
		}

FunctionDeclaration:
	T_IDENTIFIER OP_LPAREN FormalParameterList OP_RPAREN OP_LBRACE OP_RBRACE
	{
		$$ = new Symbol();
		for(String* param = (String*)$3; param; param = (String*)param->prev)
		{
			printf("PARAM: %s\n", param->value);
		}
	}

FormalParameterList
	: FormalParameterList OP_COMMA T_IDENTIFIER
		{
			$$->next = new String($3, @3);
			$$->next->prev = $$;
			$$ = $$->next;
		}
	| T_IDENTIFIER
		{
			$$ = new String($1, @1);
		}
	|
		{
			$$ = new String("", @$);
		}

SourceElement:
	IncludeDirective
		{
			$$ = (Symbol*)$1;
			$1->location.Print();
		}
	| AnimtreeDirective
		{
			$$ = (Symbol*)$1;
			$1->location.Print();
		}
	| FunctionDeclaration
		{
			$$ = $1;
		}

SourceElements:
	SourceElements SourceElement
		{
			$1->parent = NULL;
			$$->next = $1;
			$1->prev = $$;
		}
	| SourceElement
		{
			$1->prev = NULL;
			$1->parent = NULL;
			$$ = $1;
		}
	;

Program: SourceElements T_EOF
	{
	}

%%

#define DEBUG 1

void yyerror(YYLTYPE* loc, void* scanner, const char* err) {
	fprintf(stderr, "PARSE ERROR AT LINE %d(%d): %s\n",
		loc->first_line, loc->first_column,
		err);
		
#if !(DEBUG)
	exit(1);
#endif
}

extern int yylex_init(void** ptr_yy_globals);
extern int yylex_destroy(void* yyscanner);
extern void yyset_in(FILE* in, void* scanner);
extern void yyset_out(FILE* out, void* scanner);

int main(int argc, char** argv) {
FILE* in = argc > 1 ? fopen(argv[1], "r") : stdin;

#if DEBUG
while(1){
#endif
	void* myscanner;
	yylex_init(&myscanner);
	
	yyset_in(in, myscanner );
	yyset_out(stdout, myscanner);
	
	yyparse(myscanner);
	yylex_destroy(myscanner);
	
	if(argc > 1)
	{
		printf("\n");
		exit(0);
	}
#if DEBUG
}
#endif

	printf("PRESS ANY KEY TO EXIT");
	std::cin.get();

	return 0;
}
