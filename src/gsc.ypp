%{
	#include <stdio.h>
	#include <stdlib.h>
	#include <iostream>

	//#include "lex.yy.h"
	
	#include "symbol.h"
	#include "gsc.tab.hpp"

	int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, void* yyscanner);
	//extern int yyparse();
	void yyerror(YYLTYPE* loc, void* scanner, const char* err);
%}

%define api.pure full
%lex-param { void* scanner }
%parse-param { void* scanner }

%define parse.error verbose

%locations
%initial-action
{
	@$.first_line = @$.last_line = 0;
	@$.first_column = @$.last_column = 0;
}

%code requires
{
	//
	// Forward declarations for any custom classes used in YYSTYPE
	//
	class Symbol;
	class Include;
	class String;
	class Animtree;
}

%union {
	int			literal_int;
	float		literal_float;
	char*		literal_string;
	
	Symbol*		symbol;
	Include*	include;
	Animtree*	animtree;
}

%token<literal_string> T_STRING
%token<literal_float> T_FLOAT
%token<literal_string> T_INT

%token INCLUDE
%token USING_ANIMTREE
%token ANIMTREE

%token OP_LPAREN
%token OP_RPAREN
%token FUNC_POINTER_BEGIN

%token OP_LBRACKET
%token OP_RBRACKET
%token OP_LBRACE
%token OP_RBRACE
%token OP_COMMA
%token OP_INC
%token OP_DEC

%token OP_COLON_DOUBLE
%token OP_COLON
%token OP_COLON_SEMI
%token OP_QMARK
%token OP_HASH

%token T_IF
%token T_ELSE
%token T_SWITCH
%token T_CASE
%token T_DEFAULT
%token T_BREAK
%token T_FOR
%token T_WHILE
%token T_CONTINUE
%token T_RETURN
%token T_THREAD
%token T_WAIT
%token<literal_string> T_FILEPATH
%token T_IDENTIFIER

// Define Token
%token OP_INC_POST OP_DEC_POST OP_LB OP_RB OP_DOT
%token OP_INC_PRE OP_DEC_PRE OP_UPLUS OP_UMINUS OP_NOT OP_BW_NOT
%token OP_MULT OP_DIV OP_MOD
%token OP_ADD OP_SUB
%token OP_LSHIFT OP_RSHIFT
%token OP_CMP_LT OP_CMP_LE OP_CMP_GT OP_CMP_GE
%token OP_CMP_EQ OP_CMP_NEQ
%token OP_BW_AND
%token OP_BW_XOR
%token OP_BW_OR
%token OP_CMP_AND
%token OP_CMP_OR
//ternary
%token OP_ASSIGN OP_ASSIGN_ADD OP_ASSIGN_SUB OP_ASSIGN_MULT OP_ASSIGN_DIV OP_ASSIGN_BW_AND OP_ASSIGN_BW_XOR OP_ASSIGN_BW_OR

%token T_INVALID
%token T_EOF

// Operator Precedence
/*%left OP_INC_POST OP_DEC_POST OP_LB OP_RB OP_DOT
%right OP_INC_PRE OP_DEC_PRE OP_UPLUS OP_UMINUS OP_NOT OP_BW_NOT
%left OP_MULT OP_DIV OP_MOD
%left OP_ADD OP_SUB
%left OP_LSHIFT OP_RSHIFT
%left OP_CMP_LT OP_CMP_LE OP_CMP_GT OP_CMP_GE
%left OP_CMP_EQ OP_CMP_NEQ
%left OP_BW_AND
%left OP_BW_XOR
%left OP_BW_OR
%left OP_CMP_AND
%left OP_CMP_OR
//ternary
%right OP_ASSIGN OP_ASSIGN_ADD OP_ASSIGN_SUB OP_ASSIGN_MULT OP_ASSIGN_DIV OP_ASSIGN_BW_AND OP_ASSIGN_BW_XOR OP_ASSIGN_BW_OR
*/
//%type<ival> expression
//%type<fval> mixed_expression

%type<include> IncludeDirective;
%type<animtree> AnimtreeDirective;

%type<symbol> SourceElements;
%type<symbol> SourceElement;

%start Program

%%

IncludeDirective: INCLUDE T_FILEPATH
		{
			$$ = new Include(new String($2, @2), @$); 
		}
		
AnimtreeDirective: USING_ANIMTREE OP_LPAREN T_STRING OP_RPAREN OP_COLON_SEMI
		{
			$$ = new Animtree(new String($3, @3), @$); 
		}

SourceElement: IncludeDirective
		{
			$$ = (Symbol*)$1;
			$1->location.Print();
		}
	| AnimtreeDirective
		{
			$$ = (Symbol*)$1;
			$1->location.Print();
		}

SourceElements: SourceElements SourceElement
		{
			/*$$ = new Include($2);
			$$->location = @$;
		   	//$$ = new Include(@1);
			$$->location.Print();*/
		}
	| SourceElement
		{
			$$ = $1;
		}
	;

Program: SourceElements T_EOF
	{
	}

%%

#define DEBUG 1

void yyerror(YYLTYPE* loc, void* scanner, const char* err) {
	fprintf(stderr, "PARSE ERROR AT LINE %d(%d): %s\n",
		loc->first_line, loc->first_column,
		err);
		
#if !(DEBUG)
	exit(1);
#endif
}

extern int yylex_init(void** ptr_yy_globals);
extern int yylex_destroy(void* yyscanner);

int main(int argc, char** argv) {

#if DEBUG
while(1){
#endif
	void* myscanner;
	yylex_init(&myscanner);
	yyparse(myscanner);
	yylex_destroy(myscanner);
#if DEBUG
}
#endif

	printf("PRESS ANY KEY TO EXIT");
	std::cin.get();

	return 0;
}
