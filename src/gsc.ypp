%{
	#include <stdio.h>
	#include <stdlib.h>
	#include <iostream>

	#include <vector>

	int yylex();
	extern FILE* yyin;
	extern int yyparse();

	void yyerror(const char* s);
	
	#include "gsc.tab.hpp"
	
	#include <string.h>
	class Symbol
	{
		public:
			Symbol* prev;
			Symbol* next;
			
			YYLTYPE location;
			char* string;
		public:
		
			Symbol(void) : prev(NULL), next(NULL)
			{
				this->location.first_line = this->location.last_line = 0;
				this->location.first_column = this->location.last_column = 0;
				this->string = (char*)"";
			}
			
			Symbol(char* str, YYLTYPE loc) : prev(NULL), next(NULL), location(loc)
			{
				this->string = strdup(str);
			}
			
			~Symbol()
			{
				printf("DTOR\n");
			}
	};
%}

//%define api.pure full
%define parse.error verbose

%locations
%initial-action
{
	@$.first_line = @$.last_line = 0;
	@$.first_column = @$.last_column = 0;
}

%union {
	int		literal_int;
	float	literal_float;
	char*	literal_string;
	void*	src_elem;
}

%token<literal_string> T_STRING
%token<literal_float> T_FLOAT
%token<literal_string> T_INT

%token INCLUDE
%token USING_ANIMTREE
%token ANIMTREE

%token OP_LPAREN
%token OP_RPAREN
%token FUNC_POINTER_BEGIN

%token OP_LBRACKET
%token OP_RBRACKET
%token OP_LBRACE
%token OP_RBRACE
%token OP_COMMA
%token OP_INC
%token OP_DEC

%token OP_COLON_DOUBLE
%token OP_COLON
%token OP_COLON_SEMI
%token OP_QMARK
%token OP_HASH

%token T_IF
%token T_ELSE
%token T_SWITCH
%token T_CASE
%token T_DEFAULT
%token T_BREAK
%token T_FOR
%token T_WHILE
%token T_CONTINUE
%token T_RETURN
%token T_THREAD
%token T_WAIT
%token<literal_string> T_FILEPATH
%token T_IDENTIFIER

// Define Token
%token OP_INC_POST OP_DEC_POST OP_LB OP_RB OP_DOT
%token OP_INC_PRE OP_DEC_PRE OP_UPLUS OP_UMINUS OP_NOT OP_BW_NOT
%token OP_MULT OP_DIV OP_MOD
%token OP_ADD OP_SUB
%token OP_LSHIFT OP_RSHIFT
%token OP_CMP_LT OP_CMP_LE OP_CMP_GT OP_CMP_GE
%token OP_CMP_EQ OP_CMP_NEQ
%token OP_BW_AND
%token OP_BW_XOR
%token OP_BW_OR
%token OP_CMP_AND
%token OP_CMP_OR
//ternary
%token OP_ASSIGN OP_ASSIGN_ADD OP_ASSIGN_SUB OP_ASSIGN_MULT OP_ASSIGN_DIV OP_ASSIGN_BW_AND OP_ASSIGN_BW_XOR OP_ASSIGN_BW_OR

%token T_INVALID
%token T_EOF

// Operator Precedence
/*%left OP_INC_POST OP_DEC_POST OP_LB OP_RB OP_DOT
%right OP_INC_PRE OP_DEC_PRE OP_UPLUS OP_UMINUS OP_NOT OP_BW_NOT
%left OP_MULT OP_DIV OP_MOD
%left OP_ADD OP_SUB
%left OP_LSHIFT OP_RSHIFT
%left OP_CMP_LT OP_CMP_LE OP_CMP_GT OP_CMP_GE
%left OP_CMP_EQ OP_CMP_NEQ
%left OP_BW_AND
%left OP_BW_XOR
%left OP_BW_OR
%left OP_CMP_AND
%left OP_CMP_OR
//ternary
%right OP_ASSIGN OP_ASSIGN_ADD OP_ASSIGN_SUB OP_ASSIGN_MULT OP_ASSIGN_DIV OP_ASSIGN_BW_AND OP_ASSIGN_BW_XOR OP_ASSIGN_BW_OR
*/
//%type<ival> expression
//%type<fval> mixed_expression
%type<literal_string> IncludeDirective;

%type<literal_string> SourceElement;
%type<src_elem> SourceElements;
%start Program

%%

Program: SourceElements T_EOF 

SourceElement
	: IncludeDirective
	{
		//printf("0x%X %s", $1, $1);
		printf("AT %d %d %d %d\n", @1.first_line, @1.first_column, @1.last_line, @1.last_column);
		//return $1;
	}
	;
	
SourceElements
	: SourceElements SourceElement
		{
			if($1 == NULL)
			{
				$$ = new Symbol($2, @2);
			}
			else
			{
				Symbol* last = (Symbol*)$1;
				Symbol* next = new Symbol($2, @2);
				
				last->next = next;
				next->prev = last;
				
				$$ = next;
			}
			
			for(Symbol* me = (Symbol*)$$; me; me = me->prev)
			{
				printf("%d(%d) - %d(%d) %s\n",
					me->location.first_line,
					me->location.first_column,
					me->location.last_line,
					me->location.last_column,
					me->string);
			}
		}
	|
		{
			$$ = NULL;
		}
	| SourceElements error
		{
			fprintf(stderr, "ERROR AT %d(%d) - %d(%d)\n",
				@2.first_line,
				@2.first_column,
				@2.last_line,
				@2.last_column);
			//YYABORT;
		}
	;

	IncludeDirective:
		INCLUDE T_FILEPATH OP_COLON_SEMI
		{
			printf("FILE: %s\n", $2);
			$$ = $2;
		}
	;
%%

#define DEBUG 0

void yyerror(const char* err) {
	fprintf(stderr, "PARSE ERROR: %s\n", err);
#if !(DEBUG)
	exit(1);
#endif
}

int main(int argc, char** argv) {
	yyin = (argc <= 1) ? stdin : fopen(argv[1], "r");
	
#if DEBUG
	while(1)
	{
#endif
		yyparse();

#if DEBUG
	}
#endif
	printf("PRESS ANY KEY TO EXIT");
	std::cin.get();

	return 0;
}
